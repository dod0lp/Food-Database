using Food;
using System.ComponentModel.DataAnnotations.Schema;
using System.ComponentModel.DataAnnotations;
using Microsoft.EntityFrameworkCore;

namespace Food_Database_Base
{
    public static class DB_Descriptors
    {
        public static string MakeConnectionString(string server, string database, string user, string password, bool trustedServerCertificate = false)
        {
            string ret = $"Server={server};Database={database};User={user};Password={password};";
            
            if (trustedServerCertificate == true)
            {
                ret += "TrustServerCertificate = True;";
            }

            return ret;
        }
    }
    
    /// <summary>
    /// Class for using and making Food Database data, Accessing database, Making connection string for database connection [<see cref="ConnectionString"/>] <br></br>
    /// Constants for accessing database tables [starting with Table], Maximum lengths of variables [starting with Max],...
    /// </summary>
    public static class DB_Food_Descriptors
    {
        // TODO: Possibly make it so that those variables for food database are read from '.env' docker file
        // apparently not a good practice and this needs to be saved in launcsettings.json or similar
        private static readonly string server = "localhost";
        private static readonly string database = "db_food";
        private static readonly string user = "BackendCSharp";
        private static readonly string password = "Password@123";

        /// <summary>
        /// The connection string used to connect to the food database.
        /// </summary>
        /// <remarks>
        /// This string is constructed using the server, database, user, and password fields. It is utilized by the application to establish a connection to the database.
        /// <br/><br/>
        /// The connection string is generated by calling the <see cref="DB_Descriptors.MakeConnectionString"/> method, which formats the necessary parameters into a valid connection string.
        /// <br/><br/>
        /// Note: For security reasons, it is a good practice to store sensitive information such as database credentials in a secure location, for example stored in environmental variables
        /// storage, or a secure configuration service, rather than hardcoding them in the source code.
        /// </remarks>
        public static readonly string ConnectionString = DB_Descriptors.MakeConnectionString(server, database, user, password, true);

        /// <summary>
        /// The maximum allowed length for a food description in the database.
        /// </summary>
        /// <remarks>
        /// This constant defines the maximum number of characters allowed for the food description.
        /// If the description exceeds this length, it may be truncated or cause an error when saving to the database.
        /// </remarks>
        public const int MaxFoodDescriptionLength = 4_000;

        /// <summary>
        /// The maximum allowed length for a food name in the database.
        /// </summary>
        /// <remarks>
        /// This constant defines the maximum number of characters allowed for the food name.
        /// If the name exceeds this length, it may be truncated or cause an error when saving to the database.
        /// </remarks>
        public const int MaxFoodNameLength = 100;

        /// <summary>
        /// The name of the table in the database that stores food items.
        /// </summary>
        /// <remarks>
        /// This constant holds the name of the table where food data is stored without prefix of database name. It can be used to construct SQL queries and access food data.
        /// </remarks>
        public const string TableFood = "Food";

        /// <summary>
        /// The name of the table in the database that stores nutrient information.
        /// </summary>
        /// <remarks>
        /// This constant holds the name of the table where nutrient data is stored without prefix of database name. It can be used to construct SQL queries and access nutrient data.
        /// </remarks>
        public const string TableNutrients = "Nutrients";

        /// <summary>
        /// The name of the table in the database that stores food ingredients.
        /// </summary>
        /// <remarks>
        /// This constant holds the name of the table where ingredient data is stored without prefix of database name. It can be used to construct SQL queries and access ingredient data.
        /// </remarks>
        public const string TableFoodIngredients = "Ingredients";
    }

    // TODO: MapToDomain & MapToEntity for those classes

    [Table(DB_Food_Descriptors.TableNutrients)]
    public class NutrientEntity
    {
        [Key]
        [Column("Food_ID")]
        public int FoodId { get; set; }

        [Column("Energy_Kcal")]
        public int EnergyKcal { get; set; }

        [Column("Energy_Kj")]
        public int EnergyKj { get; set; }

        [Column("Fat_Total")]
        public double FatTotal { get; set; }

        [Column("Fat_Saturated")]
        public double FatSaturated { get; set; }

        [Column("Carbs_Total")]
        public double CarbsTotal { get; set; }

        [Column("Carbs_Saturated")]
        public double CarbsSaturated { get; set; }

        [Column("Protein_Total")]
        public double ProteinTotal { get; set; }

        [Column("Salt_Total")]
        public double SaltTotal { get; set; }


        // Navigation property to Food
        [ForeignKey("FoodId")]
        public FoodEntity Food { get; set; }
    }

    [Table(DB_Food_Descriptors.TableFood)]
    public class FoodEntity
    {
        [Key]
        [Column("ID")]
        public int FoodId { get; set; }

        [Column("Name")]
        public string Name { get; set; }

        [Column("Weight")]
        public double Weight { get; set; }

        [Column("Description")]
        public string Description { get; set; }

        // Navigation property to Nutrient
        public NutrientEntity Nutrient { get; set; }

        // Navigation properties for Ingredients
        public ICollection<IngredientEntity> IngredientsAsPart { get; set; } = new HashSet<IngredientEntity>();
        public ICollection<IngredientEntity> IngredientsAsComplete { get; set; } = new HashSet<IngredientEntity>();
    }

    [Table(DB_Food_Descriptors.TableFoodIngredients)]
    public class IngredientEntity
    {
        [Key]
        [Column("Food_ID_Complete")]
        public int FoodIdComplete { get; set; }

        [Key]
        [Column("Food_ID_Part")]
        public int FoodIdPart { get; set; }

        // Navigation properties
        [ForeignKey("FoodIdComplete")]
        public FoodEntity FoodComplete { get; set; }

        [ForeignKey("FoodIdPart")]
        public FoodEntity FoodPart { get; set; }
    }

    public class FoodDbContext : DbContext
    {
        /// <summary>
        /// Food table entity, mapped so that I can add also <see cref="NutrientEntity"/> and/or <see cref="IngredientEntity"/> with this when
        /// aforementioned entities are defined,
        /// but also I can simply add only <see cref="FoodEntity"/>
        /// </summary>
        public DbSet<FoodEntity> Foods { get; set; }
        public DbSet<NutrientEntity> Nutrients { get; set; }
        public DbSet<IngredientEntity> Ingredients { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlServer(DB_Food_Descriptors.ConnectionString);
        }

        /// <summary>
        /// Configures entities and keys based on database relations defined in documentation of database in<br></br>
        /// entity relation diagram
        /// </summary>
        /// <param name="modelBuilder">Model builder instance</param>
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<IngredientEntity>()
                .HasKey(i => new { i.FoodIdComplete, i.FoodIdPart });

            modelBuilder.Entity<NutrientEntity>()
                .HasOne(n => n.Food)
                .WithOne(f => f.Nutrient)
                .HasForeignKey<NutrientEntity>(n => n.FoodId);

            modelBuilder.Entity<FoodEntity>()
                .HasMany(f => f.IngredientsAsPart)
                .WithOne(i => i.FoodPart)
                .HasForeignKey(i => i.FoodIdPart);

            modelBuilder.Entity<FoodEntity>()
                .HasMany(f => f.IngredientsAsComplete)
                .WithOne(i => i.FoodComplete)
                .HasForeignKey(i => i.FoodIdComplete);
        }
    }

    /// <summary>
    /// Represents a class for mapping of Domain (C#) <see cref="Nutrients"/> to Entity (database) <see cref="NutrientEntity"/> models, and vice-versa.
    /// </summary>
    public static class NutrientMappingExtensions
    {
        /// <summary>
        /// Maps a <see cref="NutrientEntity"/> to a <see cref="Nutrients"/> domain model.
        /// </summary>
        /// <param name="entity">The <see cref="NutrientEntity"/> instance to be mapped.</param>
        /// <returns>A <see cref="Nutrients"/> domain model populated with data from the <paramref name="entity"/>.</returns>
        public static Nutrients MapToDomain(this NutrientEntity entity)
        {
            return new Nutrients(
                new Energy(entity.EnergyKcal),
                new Fat(entity.FatTotal, entity.FatSaturated),
                new Carbohydrates(entity.CarbsTotal, entity.CarbsSaturated),
                new Protein(entity.ProteinTotal),
                new Salt(entity.SaltTotal)
            );
        }

        /// <summary>
        /// Maps a <see cref="Nutrients"/> domain model to a <see cref="NutrientEntity"/> for database storage.
        /// </summary>
        /// <param name="model">The <see cref="Nutrients"/> domain model to be mapped.</param>
        /// <param name="foodId">The ID of the food item associated with this nutrient data. If database has autoincrement, this is not needed.</param>
        /// <returns>A <see cref="NutrientEntity"/> instance populated with data from the <paramref name="model"/>.</returns>
        /// <remarks>
        /// - The <see cref="EnergyKcal"/> and <see cref="EnergyKj"/> properties are cast to <c>int</c> as the database stores energy values as integers.
        /// - Other properties are cast to <c>double</c> to match the database schema for precision.
        /// - Ensure that the explicit casting does not result in data loss or precision issues.
        /// </remarks>
        public static NutrientEntity MapToEntity(this Nutrients model, int foodId = -1)
        {
            return new NutrientEntity
            {
                FoodId = foodId,
                // Energykcal is int in database, in Domain model it is double, but it is being explicitly cast as 'int'
                // when using setter
                EnergyKcal = (int)model.Energy.Kcal,
                EnergyKj = (int)model.Energy.KJ,

                FatTotal = (double)model.FatContent.Total,
                FatSaturated = (double)model.FatContent.Saturated,

                CarbsTotal = (double)model.CarbohydrateContent.Total,
                CarbsSaturated = (double)model.CarbohydrateContent.Sugar,

                ProteinTotal = (double)model.Protein.Total,
                
                SaltTotal = (double)model.Salt.Total
            };
        }
    }

    /// <summary>
    /// Represents a class for mapping of Domain (C#) <see cref="Food.Food"/> to Entity (database) <see cref="FoodEntity"/> models, and vice-versa.
    /// </summary>
    public static class FoodMappingExtensions
    {
        /// <summary>
        /// Maps a <see cref="FoodEntity"/> to a <see cref="Food.Food"/> domain model.
        /// </summary>
        /// <param name="entity">The <see cref="FoodEntity"/> instance to be mapped.</param>
        /// <returns>A <see cref="Food.Food"/> domain model populated with data from the <paramref name="entity"/>.</returns>
        public static Food.Food MapToDomain(this FoodEntity entity)
        {
            return new Food.Food(
                entity.FoodId,
                entity.Name,
                entity.Weight,
                entity.Nutrient.MapToDomain(),
                entity.Description,
                entity.IngredientsAsComplete.Select(i => i.FoodPart.MapToDomain()).ToList()
            );
        }

        /// <summary>
        /// Maps a <see cref="Food.Food"/> domain model to a <see cref="FoodEntity"/> for database storage.
        /// </summary>
        /// <param name="model">The <see cref="Food.Food"/> domain model to be mapped.</param>
        /// <returns>A <see cref="FoodEntity"/> instance populated with data from the <paramref name="model"/>.</returns>
        /// <remarks>
        /// - The <see cref="Weight"/> property is cast to <c>double</c> to match the database schema, which may store weight as a floating-point number.
        /// - The <see cref="Nutrient"/> property is mapped using <see cref="Nutrients.MapToEntity(int)"/> and associates the food item ID with the nutrient data.
        /// - Ingredients are mapped to a set of <see cref="IngredientEntity"/> instances, with each ingredient linked back to the food entity.
        /// </remarks>
        public static FoodEntity MapToEntity(this Food.Food model)
        {
            var entity = new FoodEntity
            {
                // I can't add ID in this case, because it breaks database foreignkey,...
                Name = model.Name,
<<<<<<< HEAD
                Weight = (float)model.Weight,
=======
                Weight = (double)model.Weight,
>>>>>>> sql-setup
                Description = model.Description,
                Nutrient = model.NutrientContent.MapToEntity(model.Id),
                IngredientsAsPart = new HashSet<IngredientEntity>()
            };

            // Map Ingredients
            if (model.Ingredients != null)
            {
                foreach (var ingredient in model.Ingredients)
                {
                    entity.IngredientsAsPart.Add(new IngredientEntity
                    {
                        FoodIdComplete = model.Id,
                        FoodIdPart = ingredient.Id,
                        FoodComplete = entity,
                        FoodPart = ingredient.MapToEntity()
                    });
                }
            }

            return entity;
        }
    }
}
